<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Minesweeper</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Disable standard touch interactions to prevent zooming/selection while playing */
        body {
            touch-action: none;
            /* Prevent browser scrolling completely */
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            /* No scrollbars */
        }
        /* Dynamic cell size via CSS variable set in JS */
        .cell {
            width: var(--cell-size, 32px);
            height: var(--cell-size, 32px);
            border-radius: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: calc(var(--cell-size, 32px) * 0.6);
            /* Text scales with cell */
            cursor: pointer;
        }
        .cell-closed {
            background-color: #c0c0c0;
            border-top: 2px solid #ffffff;
            border-left: 2px solid #ffffff;
            border-right: 2px solid #808080;
            border-bottom: 2px solid #808080;
        }
        .cell-closed:active {
            border: 1px solid #808080;
        }
        .cell-open {
            background-color: #d1d5db;
            border: 1px solid #9ca3af;
        }
        .num-1 {
            color: #0000ff;
        }
        .num-2 {
            color: #008000;
        }
        .num-3 {
            color: #ff0000;
        }
        .num-4 {
            color: #000080;
        }
        .num-5 {
            color: #800000;
        }
        .num-6 {
            color: #008080;
        }
        .num-7 {
            color: #000000;
        }
        .num-8 {
            color: #808080;
        }
        /* Custom scrollbar hidden */
        ::-webkit-scrollbar {
            display: none;
        }
    </style>
</head>
<body class="bg-gray-800 text-white h-screen w-screen flex flex-col items-center p-2">
    <!-- Header / Stats -->
    <div id="game-header"
        class="bg-gray-300 p-2 rounded-t-md w-full max-w-2xl border-4 border-gray-400 border-b-0 flex justify-between items-center select-none text-black shrink-0 z-10">
        <!-- Mines Counter -->
        <div class="bg-black text-red-600 font-mono text-3xl px-2 py-1 border-2 border-gray-500 inset-shadow min-w-[80px] text-center"
            id="mine-count">
            010
        </div>
        <!-- Reset Button -->
        <button id="reset-btn"
            class="w-10 h-10 border-4 border-gray-100 border-r-gray-500 border-b-gray-500 bg-gray-300 active:border-gray-500 active:border-r-gray-100 active:border-b-gray-100 flex items-center justify-center text-2xl focus:outline-none">
            ðŸ™‚
        </button>
        <!-- Timer (Distinct Look) -->
        <div class="bg-gray-900 text-green-400 font-mono text-3xl px-2 py-1 border-2 border-gray-600 inset-shadow min-w-[80px] text-center"
            id="timer">
            0:00
        </div>
    </div>
    <!-- Game Board Container -->
    <div
        class="bg-gray-300 p-1 border-4 border-gray-400 border-t-0 w-full max-w-2xl flex-1 flex flex-col items-center justify-center overflow-hidden relative">
        <div id="grid" class="grid bg-gray-400 mx-auto transition-all duration-200">
            <!-- Grid items generated by JS -->
        </div>
    </div>
    <!-- Game Over / Settings Modal -->
    <div id="modal" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50">
        <div class="bg-white text-black p-6 rounded-lg shadow-xl text-center max-w-sm w-full mx-4">
            <h2 id="modal-title" class="text-3xl font-bold mb-2">Game Over</h2>
            <p id="modal-msg" class="mb-6 text-gray-700">You hit a mine.</p>
            <div class="mb-4 text-left">
                <label class="block text-sm font-bold mb-1 text-gray-600">Select Difficulty:</label>
                <select id="modal-difficulty" class="w-full border border-gray-400 p-2 rounded text-lg">
                    <option value="easy">Easy (9x9)</option>
                    <option value="medium">Medium (16x16)</option>
                    <option value="hard">Hard (16x30)</option>
                </select>
            </div>
            <button id="modal-restart"
                class="bg-blue-600 text-white px-6 py-3 rounded hover:bg-blue-700 w-full font-bold text-lg shadow-md">Start
                New Game</button>
        </div>
    </div>
    <script>
        // Configuration
        const PRESETS = {
            easy: { rows: 9, cols: 9, mines: 10 },
            medium: { rows: 16, cols: 16, mines: 40 },
            hard: { rows: 30, cols: 16, mines: 99 }
        };
        // State
        let grid = [];
        let config = PRESETS.easy;
        let gameOver = false;
        let timerInterval = null;
        let time = 0;
        let flags = 0;
        let isFirstClick = true;
        // DOM Elements
        const gridEl = document.getElementById('grid');
        const headerEl = document.getElementById('game-header');
        const mineCountEl = document.getElementById('mine-count');
        const timerEl = document.getElementById('timer');
        const resetBtn = document.getElementById('reset-btn');
        const modal = document.getElementById('modal');
        const modalTitle = document.getElementById('modal-title');
        const modalMsg = document.getElementById('modal-msg');
        const modalRestart = document.getElementById('modal-restart');
        const modalDifficulty = document.getElementById('modal-difficulty');
        // SVGs
        const FLAG_SVG = `<svg viewBox="0 0 24 24" class="w-full h-full p-[15%] text-red-600 fill-current pointer-events-none"><path d="M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6z"/></svg>`;
        const MINE_ICON = 'ðŸ’£';
        // Initialize
        function init() {
            grid = [];
            gameOver = false;
            isFirstClick = true;
            time = 0;
            flags = 0;
            stopTimer();
            updateHeader();
            updateTimerDisplay();
            resetBtn.innerText = 'ðŸ™‚';
            // Build Grid Data
            for (let r = 0; r < config.rows; r++) {
                const row = [];
                for (let c = 0; c < config.cols; c++) {
                    row.push({
                        r, c,
                        isMine: false,
                        isOpen: false,
                        isFlagged: false,
                        neighborCount: 0,
                        id: `cell-${r}-${c}`
                    });
                }
                grid.push(row);
            }
            renderGrid();
            resizeGrid(); // Fit to screen immediately
        }
        // Dynamic Resizing Logic
        function resizeGrid() {
            const headerHeight = headerEl.offsetHeight;
            // Use visualViewport if available for better mobile accuracy (URL bars etc)
            const vh = window.visualViewport ? window.visualViewport.height : window.innerHeight;
            const vw = window.visualViewport ? window.visualViewport.width : window.innerWidth;
            // Vertical: Window - Header - BodyPad(16) - Border(4) - Pad(8) - Buffer(20) = ~48px buffer total
            // Increased buffer to 60 to be safe on mobile
            const availableHeight = vh - headerHeight - 60;
            // Horizontal: Window - BodyPad(16) - Border(8) - Pad(8) - Buffer(8) = ~40px buffer total
            // Also constrain by the max-w-2xl (approx 672px) of the container
            const containerMaxWidth = 672; // max-w-2xl is 42rem = 672px
            const windowAvailableWidth = vw - 40;
            const availableWidth = Math.min(windowAvailableWidth, containerMaxWidth - 20); // -20 for internal padding/borders
            // Calculate max possible square size
            const maxCellHeight = Math.floor(availableHeight / config.rows);
            const maxCellWidth = Math.floor(availableWidth / config.cols);
            // Choose smallest dimension to keep it square and fitting
            const cellSize = Math.min(maxCellHeight, maxCellWidth);
            // Apply
            gridEl.style.setProperty('--cell-size', `${cellSize}px`);
            gridEl.style.gridTemplateColumns = `repeat(${config.cols}, ${cellSize}px)`;
        }
        // Listen for window resize
        window.addEventListener('resize', () => {
            // Debounce slightly if needed, but direct is usually fine for this complexity
            requestAnimationFrame(resizeGrid);
        });
        function renderGrid() {
            gridEl.innerHTML = '';
            grid.forEach(row => {
                row.forEach(cell => {
                    const div = document.createElement('div');
                    div.classList.add('cell', 'cell-closed');
                    div.dataset.r = cell.r;
                    div.dataset.c = cell.c;
                    div.id = cell.id;
                    // Mouse Events
                    div.addEventListener('mousedown', (e) => {
                        if (e.button === 2) {
                            e.preventDefault();
                            toggleFlag(cell);
                        }
                    });
                    div.addEventListener('contextmenu', (e) => e.preventDefault());
                    div.addEventListener('click', () => {
                        handleInteraction(cell);
                    });
                    div.addEventListener('dblclick', () => {
                        attemptChord(cell);
                    });
                    addTouchHandlers(div, cell);
                    gridEl.appendChild(div);
                });
            });
        }
        function addTouchHandlers(div, cell) {
            let touchTimer = null;
            let startX = 0;
            let startY = 0;
            let hasMoved = false;
            let longPressTriggered = false;
            let lastTapTime = 0;
            div.addEventListener('touchstart', (e) => {
                if (gameOver) return;
                const touch = e.touches[0];
                startX = touch.clientX;
                startY = touch.clientY;
                hasMoved = false;
                longPressTriggered = false;
                touchTimer = setTimeout(() => {
                    longPressTriggered = true;
                    if (navigator.vibrate) navigator.vibrate(50);
                    toggleFlag(cell);
                }, 400);
            }, { passive: false });
            div.addEventListener('touchmove', (e) => {
                if (hasMoved) return;
                const touch = e.touches[0];
                const moveX = Math.abs(touch.clientX - startX);
                const moveY = Math.abs(touch.clientY - startY);
                if (moveX > 10 || moveY > 10) {
                    hasMoved = true;
                    clearTimeout(touchTimer);
                }
            }, { passive: true });
            div.addEventListener('touchend', (e) => {
                if (gameOver) return;
                clearTimeout(touchTimer);
                if (hasMoved || longPressTriggered) {
                    if (longPressTriggered) e.preventDefault();
                    return;
                }
                e.preventDefault();
                const currentTime = new Date().getTime();
                const tapGap = currentTime - lastTapTime;
                if (tapGap < 300 && tapGap > 0) {
                    attemptChord(cell);
                    lastTapTime = 0;
                } else {
                    handleInteraction(cell);
                    lastTapTime = currentTime;
                }
            });
        }
        function handleInteraction(cell) {
            if (gameOver || cell.isFlagged) return;
            if (cell.isOpen) return;
            if (isFirstClick) {
                placeMines(cell.r, cell.c);
                startTimer();
                isFirstClick = false;
            }
            openCell(cell);
        }
        function attemptChord(cell) {
            if (!cell.isOpen || gameOver) return;
            const neighbors = getNeighbors(cell.r, cell.c);
            const flagCount = neighbors.filter(n => n.isFlagged).length;
            if (flagCount === cell.neighborCount) {
                let chordTriggered = false;
                neighbors.forEach(n => {
                    if (!n.isOpen && !n.isFlagged) {
                        openCell(n);
                        chordTriggered = true;
                    }
                });
            }
        }
        function placeMines(safeR, safeC) {
            let minesPlaced = 0;
            while (minesPlaced < config.mines) {
                const r = Math.floor(Math.random() * config.rows);
                const c = Math.floor(Math.random() * config.cols);
                if (!grid[r][c].isMine && (Math.abs(r - safeR) > 1 || Math.abs(c - safeC) > 1)) {
                    grid[r][c].isMine = true;
                    minesPlaced++;
                }
            }
            calculateNumbers();
        }
        function calculateNumbers() {
            for (let r = 0; r < config.rows; r++) {
                for (let c = 0; c < config.cols; c++) {
                    if (grid[r][c].isMine) continue;
                    let count = 0;
                    getNeighbors(r, c).forEach(n => {
                        if (n.isMine) count++;
                    });
                    grid[r][c].neighborCount = count;
                }
            }
        }
        function getNeighbors(r, c) {
            const neighbors = [];
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    if (i === 0 && j === 0) continue;
                    const nr = r + i;
                    const nc = c + j;
                    if (nr >= 0 && nr < config.rows && nc >= 0 && nc < config.cols) {
                        neighbors.push(grid[nr][nc]);
                    }
                }
            }
            return neighbors;
        }
        function toggleFlag(cell) {
            if (gameOver || cell.isOpen) return;
            cell.isFlagged = !cell.isFlagged;
            flags += cell.isFlagged ? 1 : -1;
            const div = document.getElementById(cell.id);
            if (cell.isFlagged) {
                div.innerHTML = FLAG_SVG;
            } else {
                div.innerHTML = '';
            }
            updateHeader();
        }
        function openCell(cell) {
            if (cell.isOpen || cell.isFlagged) return;
            cell.isOpen = true;
            const div = document.getElementById(cell.id);
            div.classList.remove('cell-closed');
            div.classList.add('cell-open');
            if (cell.isMine) {
                triggerLose(cell);
                return;
            }
            if (cell.neighborCount > 0) {
                div.textContent = cell.neighborCount;
                div.classList.add(`num-${cell.neighborCount}`);
            } else {
                getNeighbors(cell.r, cell.c).forEach(n => openCell(n));
            }
            checkWin();
        }
        function triggerLose(clickedCell) {
            gameOver = true;
            stopTimer();
            resetBtn.innerText = 'ðŸ˜µ';
            const div = document.getElementById(clickedCell.id);
            div.style.backgroundColor = 'red';
            grid.forEach(row => {
                row.forEach(cell => {
                    const cellDiv = document.getElementById(cell.id);
                    if (cell.isMine) {
                        cellDiv.innerHTML = MINE_ICON;
                        // Center the mine icon
                        cellDiv.classList.add('flex', 'items-center', 'justify-center', 'text-xl');
                    } else if (cell.isFlagged) {
                        cellDiv.innerHTML = 'âŒ';
                    }
                });
            });
            showModal('Game Over', 'You stepped on a mine.');
        }
        function checkWin() {
            if (gameOver) return;
            let safeCellsInfo = 0;
            grid.forEach(row => row.forEach(cell => {
                if (cell.isOpen && !cell.isMine) safeCellsInfo++;
            }));
            const totalSafe = (config.rows * config.cols) - config.mines;
            if (safeCellsInfo === totalSafe) {
                gameOver = true;
                stopTimer();
                resetBtn.innerText = 'ðŸ˜Ž';
                grid.forEach(row => row.forEach(cell => {
                    if (cell.isMine && !cell.isFlagged) {
                        cell.isFlagged = true;
                        const div = document.getElementById(cell.id);
                        div.innerHTML = FLAG_SVG;
                    }
                }));
                flags = config.mines;
                updateHeader();
                showModal('You Win!', `Time: ${formatTime(time)}`);
            }
        }
        function updateHeader() {
            const remaining = config.mines - flags;
            mineCountEl.innerText = remaining.toString().padStart(3, '0');
        }
        function formatTime(seconds) {
            const m = Math.floor(seconds / 60);
            const s = seconds % 60;
            return `${m}:${s.toString().padStart(2, '0')}`;
        }
        function updateTimerDisplay() {
            timerEl.innerText = formatTime(time);
        }
        function startTimer() {
            stopTimer();
            timerInterval = setInterval(() => {
                time++;
                updateTimerDisplay();
            }, 1000);
        }
        function stopTimer() {
            if (timerInterval) clearInterval(timerInterval);
        }
        function showModal(title, msg) {
            modalTitle.innerText = title;
            modalMsg.innerText = msg;
            // Sync difficulty selector to current config
            // Find which key matches current config
            let currentKey = 'easy';
            for (const [key, val] of Object.entries(PRESETS)) {
                if (val.rows === config.rows && val.cols === config.cols) {
                    currentKey = key;
                    break;
                }
            }
            modalDifficulty.value = currentKey;
            modal.classList.remove('hidden');
        }
        // Event Listeners
        resetBtn.addEventListener('click', init);
        modalRestart.addEventListener('click', () => {
            const selectedDifficulty = modalDifficulty.value;
            config = PRESETS[selectedDifficulty];
            modal.classList.add('hidden');
            init();
        });
        // Initialize with Easy
        init();
    </script>
</body>
</html>
